/** This module contains helper functions for reading and writing git objects
*
**/
use anyhow::{Context, Ok, Result, bail, ensure};
use flate2::read::ZlibDecoder;
use std::ffi::CStr;
use std::io::BufRead;
use std::io::{BufReader, Cursor};
use std::{fmt, io::Read, path::Path};

pub(crate) enum GitObjectType {
    Blob,
    Tree,
    Commit,
}

impl fmt::Display for GitObjectType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            GitObjectType::Blob => write!(f, "blob"),
            GitObjectType::Tree => write!(f, "tree"),
            GitObjectType::Commit => write!(f, "commit"),
        }
    }
}

impl TryFrom<&str> for GitObjectType {
    type Error = anyhow::Error;

    fn try_from(value: &str) -> std::result::Result<Self, Self::Error> {
        match value {
            "blob" => Ok(Self::Blob),
            "tree" => Ok(Self::Tree),
            "commit" => Ok(Self::Commit),
            _ => bail!("invalid kind: {value}"),
        }
    }
}

// the main idea behind this is that different methods will return a git object with the correct
// kind, and a reader that you can use to read the remaining bytes fr with the correct kind, and a
// reader that you can use to read the remaining bytes from.
pub(crate) struct GitObject<R> {
    kind: GitObjectType,
    expected_length: usize,
    reader: R,
}

impl GitObject<()> {
    // whenever we are traversing a tree and know the type of the file is not a dir, we can use
    // this function to load it in
    pub(crate) fn read_blob_from_file(
        filename: impl AsRef<Path>,
    ) -> Result<GitObject<impl BufRead>> {
        // make sure the file exists
        ensure!(
            Path::new(filename.as_ref()).exists(),
            "file to read blob from does not exist"
        );

        // open the file
        // TODO: Some filesystems allow non UTF-8 filenames
        let f = std::fs::File::open(filename.as_ref()).with_context(|| {
            format!(
                "open blob with hash {:?} for reading",
                filename.as_ref().to_str()
            )
        })?;

        // convert the file into a bufreader for improve performance
        let mut r = BufReader::new(f);

        // read everything into an in memory buffer
        let mut buf: Vec<u8> = Vec::new();
        r.read_to_end(&mut buf)
            .context("read git blob into memory")?;

        // get the length
        let length = buf.len();

        // convert the in memory buffer into a cursor so that it can be passed back
        let cur = Cursor::new(buf);

        Ok(GitObject {
            kind: GitObjectType::Blob,
            expected_length: length,
            reader: cur,
        })
    }

    pub(crate) fn read(hash: &str) -> Result<GitObject<impl BufRead>> {
        // first we need to split the hash into its dir and remaining bytes
        ensure!(hash.len() == 40, "hash length not 40 hex characters");
        let (dir, filename) = hash.split_at(2);
        let object_path = format!(".git/objects/{}/{}", dir, filename);

        // open the file
        let f = std::fs::File::open(&object_path)
            .with_context(|| format!("read object {object_path}"))?;

        // stream through our decoder, decoding bytes as they pass through
        let zd = ZlibDecoder::new(f);

        // wrap the decoder in a bufread so that the reads are a bit cheaper
        let mut br = BufReader::new(zd);

        // if we read until the nukll byte, we have both the type and the length of the payload
        let mut buf: Vec<u8> = Vec::with_capacity(64);
        let type_and_length = {
            let x = br
                .read_until(0, &mut buf)
                .context("read type and length into buf")?;

            CStr::from_bytes_with_nul(&buf).context("convert header into CStr")
        }?;

        // because the header should be valid ASCII, and ASCII is a subset of UTF-8, we should be
        // able to convert the header into UTF-8
        let (kind, length) = type_and_length
            .to_str()
            .context("convert header CStr into UTF-8")?
            .split_once(' ')
            .context("split header on space to get kind and length")?;

        // parse the kind
        let kind: GitObjectType = kind
            .try_into()
            .context("convert kind str into kind object")?;

        // parse the length
        let length: usize = length
            .parse::<usize>()
            .context("convert length str into usize")?;

        Ok(GitObject {
            kind,
            expected_length: length,
            reader: br,
        })
    }
}
